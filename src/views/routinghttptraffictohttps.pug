extends layout 
block content 
  .row
    .col-md-8.post-container
      h1 Routing HTTP Traffic to HTTPS
      h2 10 Jan 2020
      p This post is going to be short. It’s mostly for my own/ future use (provided my setup is the same), but I suppose the principal of the lesson I learned is applicable elsewhere, too.
      p I wanted incoming traffic to be HTTPS because I spent a while learning how to create SSL certs for the website. But the domain is only valid if it uses a specific URL, so here’s what I came up with.
      p Routing all non www. traffic:
      pre.hljs
        code. 
          const app = express();
          app.enable('trust proxy');
      
          app.use((req, res, next) => {
              if (req.headers.host.slice(0, 4) !== 'www.') {
                  var newHost = 'www.' + req.headers.host;
                  return res.redirect(301, req.protocol + '://' + newHost + req.originalUrl);
              }
              next();
          }); 
      
      p Be careful with reading from ‘/’ with fs, you will likely need to mess with file permissions.
      pre.hljs
        code. 
          const generateHTTPSData = () => {
              return {
                  key: fs.readFileSync('/etc/letsencrypt/live/www.mfarstad.com/privkey.pem'),
                  cert: fs.readFileSync('/etc/letsencrypt/live/www.mfarstad.com/cert.pem'),
                  ca: fs.readFileSync('/etc/letsencrypt/live/www.mfarstad.com/chain.pem')
              }
          }
      
      p This is the annoying part. I tried various other solutions that claimed to be http-https routing packages, but I either couldn’t get them to work or they were for websites less complicated than mine. So you have to create a TLS router on {desiredPort} that pipes the connection to the appropriate port (http: {desiredPort + 1}, https: {desiredPort + 2}}).
      pre.hljs
        code. 
      
          net.createServer((conn) => {
              conn.once('data', (buf) => {
                  // A TLS handshake record starts with byte 22.
                  var address = (buf[0] === 22) ? port + 2 : port + 1;
                  var proxy = net.createConnection(address, () => {
                          proxy.write(buf);
                      conn.pipe(proxy).pipe(conn);
                  });
              })
          }).listen(port);
      
      p I don’t like this solution because there are 3 servers running concurrently (ewww…) but trust me, I tried finding some other way. If anything this experience has taught me what express.js is capable of and what to use it for. I mainly like the whole view rendering thing for pug, but realistically I won’t be using pug professionally, and even then I didn’t exactly look very hard at other node.js solutions for web servers. I’ll likely just default to some AWS default thing that handles all of this automatically.
      p But I don’t know, I feel like having this level of control is a good thing… Having a VM in cloud suited my needs, and I can use it to host whatever I need, even if it’s not a website. And I’ve learned a lot doing it! So that’s always a good thing.
      p Anyway, http server just routes to https. Took a while to figure out how to get express to play nice with user defined ports, since http and https are 80 and 443 by default, respectively.
      pre.hljs
        code. 
          http.createServer((req, res) => {
              var host = req.headers['host'];
              res.writeHead(301, { "Location": "https://" + host + req.url });
              res.end();
          }).listen(port + 1);
      
          var secureServer = https.createServer(generateHTTPSData(), app);
      
      
      
      p That’s all, folks!